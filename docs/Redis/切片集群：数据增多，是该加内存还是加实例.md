在使用 RDB 进行持久化时Redis 会 fork 子进程来完成，fork 操作的用时和 Redis 的数据量是正相关的，而 fork 在执行时会阻塞主线程，数据量越大fork 操作造成的主线程阻塞的时间越长。所以在使用 RDB 对 25GB 的数据进行持久化时，数据量较大后台运行的子进程在 fork 创建时阻塞了主线程，于是就导致 Redis 响应变慢。

第一个方案显然是不可行，需要寻找其他方案，此时注意到 Redis 的切片集群。虽然组建切片集群比较麻烦，但是它可以保存大量数据，而且对 Redis 主线程的阻塞影响较小。切片集群也叫分片集群，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则把收到的数据划分成多份，每一份用一个实例来保存。回到刚刚的场景，如果把 25GB 的数据平均分成 5 份（当然，也可以不做均分），使用 5 个实例来保存，每个实例只需要保存 5GB 数据。如下图所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/49a0ab96f3e649e0a284d452c26695af.png)
那么在切片集群中，实例在为 5GB 数据生成 RDB 时数据量就小很多，fork 子进程一般不会给主线程带来较长时间的阻塞。采用多个实例保存数据切片后，既能保存 25GB 数据，又避免 fork 子进程阻塞主线程而导致的响应突然变慢。在实际应用 Redis 时，随着用户或业务规模的扩展保存大量数据的情况通常是无法避免的。而切片集群，就是一个非常好的解决方案。
# 如何保存更多数据
为了保存大量数据使用大内存云主机和切片集群两种方法。实际上这两种方法分别对应着Redis应对数据流增多的两种方案：纵向扩展和横向扩展。

 - 纵向扩展：升级单个Redis实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的CPU。如下图原来实例内存是8GB，硬盘是50GB，纵向扩展后内存增加到24GB，磁盘增加到150GB。
 - 横向扩展：横向增加当前Redis实例个数，如下图原来使用1个8GB内存、50GB磁盘的实例，现在使用三个相同配置的实例。
![在这里插入图片描述](https://img-blog.csdnimg.cn/7700fa112c034d84aa1757df7e4c88e9.png)
首先纵向扩展好处是实施起来简单、直接。不过也存在问题：
 - 当使用 RDB 对数据进行持久化时，如果数据量增加需要的内存也会增加，主线程 fork 子进程时就可能会阻塞（比如刚刚的例子中的情况）。不过如果不要求持久化保存 Redis 数据，那么纵向扩展会是一个不错的选择。
 - 纵向扩展会受到硬件和成本的限制。这很容易理解，毕竟把内存从 32GB 扩展到 64GB 还算容易，但是要想扩充到 1TB，就会面临硬件容量和成本上的限制

与纵向扩展相比横向扩展是一个扩展性更好的方案。这是因为要想保存更多的数据，采用这种方案的话，只用增加 Redis 的实例个数即可，不用担心单个实例的硬件和成本限制。在面向百万、千万级别的用户规模时，横向扩展的 Redis 切片集群会是一个非常好的选择。不过在只使用单个实例的时候，数据存在哪儿，客户端访问哪儿，都是非常明确的，但是切片集群不可避免地涉及到多个实例的分布式管理问题。要想把切片集群用起来就需要解决两大问题：
 - 数据切片后在多个实例之间如何分布
 - 客户端如何确定想要访问的数据在哪个实例上
# 数据切片和实例对应分布关系
在切片集群中数据需要分布在不同实例上，那么数据和实例之间如何对应呢？这就和 Redis Cluster 方案有关。
实际上，切片集群是一种保存大量数据的通用机制，这个机制可以有不同的实现方案。在 Redis 3.0 之前官方并没有针对切片集群提供具体的方案。从 3.0 开始官方提供了一个名为 Redis Cluster 的方案，用于实现切片集群。Redis Cluster 方案中就规定数据和实例的对应规则。

具体来说Redis Cluster 方案采用哈希槽（Hash Slot，接下来我会直接称之为 Slot），来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key被映射到一个哈希槽中。具体的映射过程分为两大步：首先根据键值对的 key，按照CRC16 算法计算一个 16 bit 的值；然后再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。

那么，这些哈希槽又是如何被映射到具体的 Redis 实例上的呢？在部署 Redis Cluster 方案时，可以使用 cluster create 命令创建集群，此时Redis 会自动把这些槽平均分布在集群实例上。例如如果集群中有 N 个实例，那么每个实例上的槽个数为 16384/N 个。当然也可以使用 cluster meet 命令手动建立实例间的连接形成集群，再使用 cluster addslots 命令，指定每个实例上的哈希槽个数。

举个例子，假设集群中不同 Redis 实例的内存大小配置不一，如果把哈希槽均分在各个实例上，在保存相同数量的键值对时和内存大的实例相比，内存小的实例就会有更大的容量压力。遇到这种情况时可以根据不同实例的资源配置情况，使用 cluster addslots 命令手动分配哈希槽。如下图所示是数据、哈希槽、实例这三者的映射分布情况。
![在这里插入图片描述](https://img-blog.csdnimg.cn/01018bbddf0a40b8a900cf81e196a129.png)
上图所示的切片集群一共有 3 个实例，同时假设有 5 个哈希槽，首先可以通过下面的命令手动分配哈希槽：实例 1 保存哈希槽 0 和 1，实例 2 保存哈希槽 2 和 3，实例 3 保存哈希槽 4。
```java
redis-cli -h 172.16.19.3 –p 6379 cluster addslots 0,1
redis-cli -h 172.16.19.4 –p 6379 cluster addslots 2,3
redis-cli -h 172.16.19.5 –p 6379 cluster addslots 4
```
在集群运行的过程中，key1 和 key2 计算完 CRC16 值后，对哈希槽总个数 5 取模再根据各自的模数结果，就可以被映射到对应的实例 1 和实例 3 上。<font color=#900>另外需要注意的是在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。</font>  通过哈希槽切片集群可以实现数据到哈希槽、哈希槽到实例的分配。但是即使实例存储哈希槽的映射信息，但是客户端又是如何确定要访问的数据存储在哪个实例上的？
# 客户端如何定位数据
在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行。但是要进一步定位到实例，还需要知道哈希槽分布在哪个实例上。

一般来说，客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发送给客户端。但是在集群刚刚创建的时候，每个实例只知道自己被分配哪些哈希槽，是不知道其他实例拥有的哈希槽信息。那么客户端为什么可以在访问任何一个实例时，都能获得所有的哈希槽信息呢？这是因为Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系。

客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求。但是在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个：

 - 在集群中，实例有新增或删除，Redis 需要重新分配哈希槽；
 - 为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。

此外实例之间还可以通过相互传递消息，获得最新的哈希槽分配信息，但是客户端是无法主动感知这些变化的。这就会导致，它缓存的分配信息和最新的分配信息不一致，此时Redis Cluster 方案提供一种重定向机制，所谓的“重定向”，就是指客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，客户端要再给一个新实例发送操作命令。客户端又是怎么知道重定向时的新实例的访问地址呢？当客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽，那么该实例就会给客户端返回下面的 MOVED 命令响应结果，这个结果中就包含新实例的访问地址。

```java
GET hello:key
(error) MOVED 13320 172.16.19.5:6379
```
其中MOVED 命令表示，客户端请求的键值对所在的哈希槽 13320，实际是在 172.16.19.5 实例上。通过返回的 MOVED 命令，就相当于把哈希槽所在的新实例的信息告诉给客户端。这样的话客户端就可以直接和 172.16.19.5 连接，并发送操作请求。如下图所示是 MOVED 重定向命令的使用方法，可以看到由于负载均衡，Slot 2 中的数据已经从实例 2 迁移到实例 3，但是客户端缓存仍然记录着“Slot 2 在实例 2”的信息，所以会给实例 2 发送命令。此时实例 2 给客户端返回一条 MOVED 命令，把 Slot 2 的最新位置（也就是在实例 3 上）返回给客户端，客户端就会再次向实例 3 发送请求，同时还会更新本地缓存，把 Slot 2 与实例的对应关系更新过来。
![在这里插入图片描述](https://img-blog.csdnimg.cn/eba70e564b7540cfba7f88267e05964a.png)
需要注意的是，在上图中当客户端给实例 2 发送命令时，Slot 2 中的数据已经全部迁移到实例 3。在实际应用时如果 Slot 2 中的数据比较多就可能会出现一种情况：客户端向实例 2 发送请求，但此时Slot 2 中的数据只有一部分迁移到实例 3，还有部分数据没有迁移。在这种迁移部分完成的情况下客户端就会收到一条 ASK 报错信息，如下所示：
```java
GET hello:key
(error) ASK 13320 172.16.19.5:6379
```
这个结果中的 ASK 命令就表示客户端请求的键值对所在的哈希槽 13320，在 172.16.19.5 实例上，但是这个哈希槽正在迁移。此时客户端需要先给 172.16.19.5 这个实例发送一个 ASKING 命令。此命令意思是让此实例允许执行客户端接下来发送的命令。然后客户端再向这个实例发送 GET 命令，以读取数据。在下图中 Slot 2 正在从实例 2 往实例 3 迁移，key1 和 key2 已经迁移过去，key3 和 key4 还在实例 2。客户端向实例 2 请求 key2 后，就会收到实例 2 返回的 ASK 命令。ASK 命令表示两层含义：第一，表明 Slot 数据还在迁移中；第二，ASK 命令把客户端所请求数据的最新实例地址返回给客户端，此时客户端需要给实例 3 发送 ASKING 命令，然后再发送操作命令。
![在这里插入图片描述](https://img-blog.csdnimg.cn/d350b3cfc37745af9ee8ea80843149fa.png)
和 MOVED 命令不同，ASK 命令并不会更新客户端缓存的哈希槽分配信息。在上图中如果客户端再次请求 Slot 2 中的数据，它还是会给实例 2 发送请求。也就意味着 ASK 命令的作用只是让客户端能给新实例发送一次请求，而不像 MOVED 命令那样会更改本地缓存，从而让后续所有命令都发往新实例。

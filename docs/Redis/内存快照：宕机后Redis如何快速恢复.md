AOF的好处是每次执行只需要记录操作命令，需要持久化的数据量不大。一般而言只要采用的不是always持久化策略就不会对性能造成太大的影响。因为AOF记录的是操作记录而不是实际数据，因此使用AOF方法进行故障恢复时候需要逐一把操作日志都执行一遍。如果操作日志很多Redis会恢复很缓慢，会影响到正常使用。

此时需要一种在宕机时快速恢复的方式，那就是内存快照。所谓内存快照就是指内存中的数据在某一个时刻的状态记录。

对Redis来说实现类似照片记录效果的方式就是把某一时刻的状态以文件形式写到磁盘上，也就是快照。这样的话即使宕机快照文件也不会丢失，数据可靠性就得到了保证。这个快照文件称为RDB文件，其中RDB就是Redis DataBase缩写。

和AOF相比，RDB记录的是某一时刻的数据并不是操作，因此在做数据恢复的时候可以直接把RDB文件读入内存，很快完成恢复。但是RDB也不是最优选项。

这里需要考虑两个关键问题：

 - 对哪些数据做快照？这个关系到快照执行效率问题
 - 做快照时，数据还能被增删改吗？这关系到Redis是否被阻塞，能否同时正常处理请求

# 给哪些内存数据做快照
Redis数据都在内存中，为了提供所有数据的可靠性保证，执行的是全量快照。就是说会把内存中的所有数据都记录到磁盘中。这样做的好处是一次性记录所有数据一个都不少。

但是给内存的全量数据做快照把他们全部写入到磁盘就要花费很多时间，而且全量数据越多RDB文件就会越大、往磁盘上写数据的时间开销就越大。

对Redis而言其单线程就决定要避免所有会阻塞主线程的操作，因此做任何操作都要问一下其是否会阻塞主线程。RDB文件的生成是否会阻塞主线程，这个是关系到是否会降低Redis性能。

Redis提供两个命令来生成RDB文件，分别是save和bgsave。

 - save：在主线程中执行，会导致阻塞；
 - bgsave：创建一个子线程，专门用于写入RDB文件避免了主线程的阻塞(默认配置)

# 快照时数据能修改吗
但是，如果快照执行期间数据不能被修改，是会有潜在问题的。对于刚刚的例子来说，在做快照的 20s 时间里，如果这 4GB 的数据都不能被修改，Redis 就不能处理对这些数据的写操作，那无疑就会给业务服务造成巨大的影响。

避免阻塞和正常处理写操作并不是一回事。此时主线程的确没有阻塞，可以正常接收请求，但是为了保证快照完整性，它只能处理读操作，因为不能修改正在执行快照的数据。

为了快照而暂停写操作，肯定是不能接受的。所以这个时候Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。

简单来说，bgsave子进程是由主线程fork生成的，可以共享主线程的所有内存数据。bgsave子进程运行后开始读取主线程的内存数据，并把它们写入 RDB 文件。

此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么主线程和 bgsave 子进程相互不影响。但是如果主线程要修改一块数据（例如图中的键值对 C），那么这块数据就会被复制一份，生成该数据的副本（键值对 C’）。然后主线程在这个数据副本上进行修改。同时bgsave 子进程可以继续把原来的数据（键值对 C）写入 RDB 文件。
![在这里插入图片描述](https://img-blog.csdnimg.cn/9a8dc2bd790942979c66aa4cba9abb7f.jpeg#pic_center)
这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响。现在解决了对“哪些数据做快照”以及“做快照时数据能否修改”这两大问题：Redis 会使用 bgsave 对当前内存中的所有数据做快照，这个操作是子进程在后台完成的，这就允许主线程同时可以修改数据。
# 可以多秒做一次快照吗
对于快照来说，所谓“连拍”就是指连续地做快照。这样一来快照的间隔时间变得很短，即使某一时刻发生宕机了因为上一时刻快照刚执行丢失的数据也不会太多。但是这其中的快照间隔时间就很关键。

如下图所示先在 T0 时刻做一次快照，然后又在 T0+t 时刻做一次快照，在这期间数据块5和9被修改。如果在t这段时间内机器宕机，那么只能按照 T0 时刻的快照进行恢复。此时数据块5和9的修改值因为没有快照记录，就无法恢复。
![在这里插入图片描述](https://img-blog.csdnimg.cn/97a857e8d4694d948191a1292469ba30.png)
所以，要想尽可能恢复数据，t 值就要尽可能小，t 越小就越像“连拍”。那么t 值可以小到什么程度呢，比如说是不是可以每秒做一次快照？毕竟，每次快照都是由bgsave子进程在后台执行，也不会阻塞主线程。

这种想法其实是错误的。虽然 bgsave 执行时不阻塞主线程，但是如果频繁地执行全量快照，也会带来两方面的开销。

一方面，频繁将全量数据写入磁盘会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完后一个又开始做，容易造成恶性循环。
另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然子进程在创建后不会再阻塞主线程，但是fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了（所以，在 Redis 中如果有一个 bgsave 在运行，就不会再启动第二个 bgsave 子进程）。那么有什么其他好方法吗？

此时可以做增量快照，所谓增量快照，就是指做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。在第一次做完全量快照后T1 和 T2 时刻如果再做快照，只需要将被修改的数据写入快照文件就行。但是这么做的前提是需要记住哪些数据被修改了。不要小瞧这个“记住”功能，它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。如下图所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/1a6bb371beda46a19bdc2c1d91521bfc.png)
如果我们对每一个键值对的修改都做个记录，那么如果有 1 万个被修改的键值对，就需要有 1 万条额外的记录。而且，有的时候键值对非常小，比如只有 32 字节，而记录它被修改的元数据信息可能就需要 8 字节，这样的话为了“记住”修改，引入的额外空间开销比较大。这对于内存资源宝贵的 Redis 来说有些得不偿失。

到这里可以发现，虽然跟 AOF 相比，快照的恢复速度快，但是快照的频率不好把握，如果频率太低两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高又会产生额外开销，那么还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？

Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。

这样一来快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且AOF 日志也只用记录两次快照间的操作，也就是说不需要记录所有操作，因此就不会出现文件过大的情况，也可以避免重写开销。

如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录等到第二次做全量快照时就可以清空 AOF 日志，因为此时的修改都已经记录到快照中，恢复时就不再用日志。
![在这里插入图片描述](https://img-blog.csdnimg.cn/a802f2dfc8664c4f86d25a680a9db0c4.png)
这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势，颇有点“鱼和熊掌可以兼得”的感觉。

在实际应用 Redis 缓存时经常会遇到一些异常问题，概括来说有 4 个方面：

 - 缓存中的数据和数据库中的不一致
 - 缓存雪崩
 - 缓存击穿
 - 缓存穿透

只要使用 Redis 缓存就必然会面对缓存和数据库间的一致性保证问题，最重要的是如果数据不一致，那么业务应用从缓存中读取的数据就不是最新数据这样就会导致严重的错误。比如说把电商商品的库存信息缓存在 Redis 中，如果库存信息不对那么业务层下单操作就可能出错这是不能接受的。
# 缓存和数据库数据不一致是如何发生的
此处的“一致性”包含两种情况：

 - 缓存中有数据，那么缓存的数据值需要和数据库中的值相同；
 - 缓存中本身没有数据，那么数据库中的值必须是最新值。

不符合这两种情况的，就属于缓存和数据库的数据不一致问题。不过当缓存的读写模式不同时，缓存数据不一致的发生情况不一样对应的处理方法也会有所不同，所以先按照缓存读写模式来分别了解下不同模式下的缓存不一致情况。根据是否接收写请求把缓存分成读写缓存和只读缓存。对于读写缓存来说如果要对数据进行增删改，就需要在缓存中进行同时还要根据采取的写回策略，决定是否同步写回到数据库中。

 - 同步直写策略：写缓存时也同步写数据库，缓存和数据库中的数据一致；
 - 异步写回策略：写缓存时不同步写数据库，等到数据从缓存中淘汰时，再写回数据库。使用这种策略时如果数据还没有写回数据库缓存就发生故障，那么此时数据库就没有最新的数据。

所以对于读写缓存来说要想保证缓存和数据库中的数据一致，就要采用同步直写策略。不过需要注意的是如果采用这种策略，就需要同时更新缓存和数据库。所以需要在业务应用中使用事务机制来保证缓存和数据库的更新具有原子性，也就是说两者要不一起更新要不都不更新，返回错误信息进行重试，否则就无法实现同步直写。当然在有些场景下对数据一致性的要求可能不是那么高，比如说缓存的是电商商品的非关键属性或者短视频的创建或修改时间等，那么可以使用异步写回策略。

对于只读缓存来说，如果有数据新增会直接写入数据库；而有数据删改时就需要把只读缓存中的数据标记为无效。这样一来应用后续再访问这些增删改的数据时，因为缓存中没有相应的数据就会发生缓存缺失。此时应用再从数据库中把数据读入缓存，这样后续再访问数据时就能够直接从缓存中读取。以 Tomcat 向 MySQL 中写入和删改数据为例解释一下，数据的增删改操作具体是如何进行的。如下图所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/8bf5abae7ba6403594bcc492fc0f6b51.png)
从图中可以看到 Tomcat 上运行的应用，无论是新增（Insert 操作）、修改（Update 操作）、还是删除（Delete 操作）数据 X，都会直接在数据库中增改删。当然如果应用执行的是修改或删除操作，还会删除缓存的数据 X。那么这个过程中会不会出现数据不一致的情况？考虑到新增数据和删改数据的情况不一样，所以分开来看。
1. 新增数据如果是新增数据，数据会直接写到数据库中，不用对缓存做任何操作，此时缓存中本身就没有新增数据，而数据库中是最新值，这种情况符合我们刚刚所说的一致性的第 2 种情况，所以此时缓存和数据库的数据是一致的。
2. 删改数据如果发生删改操作，应用既要更新数据库也要在缓存中删除数据。这两个操作如果无法保证原子性也就是说要不都完成要不都没完成，此时就会出现数据不一致问题。假设应用先删除缓存再更新数据库，如果缓存删除成功但是数据库更新失败，那么应用再访问数据时，缓存中没有数据就会发生缓存缺失。然后应用再访问数据库，但是数据库中的值为旧值应用就访问到旧值。
![在这里插入图片描述](https://img-blog.csdnimg.cn/c4f3800f14f947a99213c5ab89024900.png)
应用要把数据 X 的值从 10 更新为 3，先在 Redis 缓存中删除了 X 的缓存值，但是更新数据库却失败了。如果此时有其他并发的请求访问 X，会发现 Redis 中缓存缺失，紧接着，请求就会访问数据库，读到的却是旧值 10。你可能会问，如果我们先更新数据库，再删除缓存中的值，是不是就可以解决这个问题呢？我们再来分析下。如果应用先完成了数据库的更新，但是，在删除缓存时失败了，那么，数据库中的值是新值，而缓存中的是旧值，这肯定是不一致的。这个时候，如果有其他的并发请求来访问数据，按照正常的缓存访问流程，就会先在缓存中查询，但此时，就会读到旧值了。我还是借助一个例子来说明一下。![在这里插入图片描述](https://img-blog.csdnimg.cn/50b1105969e34daab49a70166a9456a3.png)
应用要把数据 X 的值从 10 更新为 3，先成功更新数据库，然后在 Redis 缓存中删除 X 的缓存但是这个操作却失败，这个时候数据库中 X 的新值为 3，Redis 中的 X 的缓存值为 10，这肯定是不一致的。如果刚好此时有其他客户端也发送请求访问 X，会先在 Redis 中查询该客户端会发现缓存命中，但是读到的却是旧值 10。在更新数据库和删除缓存值的过程中无论这两个操作的执行顺序谁先谁后，只要有一个操作失败就会导致客户端读取到旧值。
![在这里插入图片描述](https://img-blog.csdnimg.cn/97ee1421ce20492182e4e05e038774e2.png)
# 如何解决数据不一致问题？
重试机制。具体来说可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用 Kafka 消息队列）。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值然后再次进行删除或更新。如果能够成功地删除或更新就要把这些值从消息队列中去除以免重复操作，此时也可以保证数据库和缓存的数据一致。否则的话还需要再次进行重试。如果重试超过的一定次数还是没有成功，就需要向业务层发送报错信息。下图显示的是先更新数据库再删除缓存值时，如果缓存删除失败，再次重试后删除成功的情况。
![在这里插入图片描述](https://img-blog.csdnimg.cn/22bcfb7389de422988abb46c30514100.png)
刚刚说的是在更新数据库和删除缓存值的过程中，其中一个操作失败的情况，实际上即使这两个操作第一次执行时都没有失败，当有大量并发请求时应用还是有可能读到不一致的数据。同样按照不同的删除和更新顺序分成两种情况来看。在这两种情况下解决方法也有所不同。

情况一：先删除缓存，再更新数据库。
假设线程 A 删除缓存值后，还没有来得及更新数据库（比如说有网络延迟），线程 B 就开始读取数据，那么这个时候线程 B 会发现缓存缺失就只能去数据库读取。这会带来两个问题：线程 B 读取到旧值；线程 B 是在缓存缺失的情况下读取的数据库，所以它还会把旧值写入缓存，这可能会导致其他线程从缓存中读到旧值。等到线程 B 从数据库读取完数据、更新缓存后，线程 A 才开始更新数据库，此时缓存中的数据是旧值，而数据库中的是最新值，两者就不一致。
![在这里插入图片描述](https://img-blog.csdnimg.cn/f73bdfecd12644d88e1a89a75cb77807.png)
解决方案：在线程 A 更新完数据库值以后可以让它先 sleep 一小段时间，再进行一次缓存删除操作。之所以要加上 sleep 的这段时间就是为了让线程 B 能够先从数据库读取数据，再把缺失的数据写入缓存，然后线程 A 再进行删除。所以线程 A sleep 的时间就需要大于线程 B 读取数据再写入缓存的时间。时间确定的方式是建议在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，以此为基础来进行估算。这样一来其它线程读取数据时会发现缓存缺失，所以会从数据库中读取最新值。因为这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除所以也把它叫做“延迟双删”。下面的这段伪代码就是“延迟双删”方案的示例，你可以看下。
```java
redis.delKey(X)
db.update(X)
Thread.sleep(N)
redis.delKey(X)
```
情况二：先更新数据库值，再删除缓存值。
如果线程 A 删除数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据，那么此时线程 B 查询缓存时发现缓存命中就会直接从缓存中读取旧值。不过在这种情况下如果其他线程并发读缓存的请求不多，那么就不会有很多请求读取到旧值。而且线程 A 一般也会很快删除缓存值，这样一来其他线程再次读取时就会发生缓存缺失进而从数据库中读取最新值。所以这种情况对业务的影响较小。
![在这里插入图片描述](https://img-blog.csdnimg.cn/e24debb4cf7445d78316a807619264c1.png)
缓存和数据库的数据不一致一般是由两个原因导致的提供了相应的解决方案。

 - 删除缓存值或更新数据库失败而导致数据不一致，可以使用重试机制确保删除或更新操作成功。
 - 在删除缓存值、更新数据库的这两步操作中，有其他线程的并发读操作导致其他线程读取到旧值，应对方案是延迟双删。

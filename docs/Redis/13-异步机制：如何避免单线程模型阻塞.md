# Redis 实例存在的阻塞点
Redis 实例在运行时要和许多对象进行交互，这些不同的交互就会涉及不同的操作。看看和 Redis 实例交互的对象，以及交互时会发生的操作。

 - 客户端：网络io，键值对增删改查操作，数据库操作
 - 磁盘：生成rdb快照，记录aof日志，aof日志重写
 - 主从节点：主库生成、传输rdb文件，从库接收rdb文件、清空数据库、加载rdb文件
 - 切片集群实例：向其他实例传输哈希槽信息，数据迁移
![在这里插入图片描述](https://img-blog.csdnimg.cn/d870ef31330547598e62ba4770f8870c.png)
1. 和客户端交互时的阻塞点

网络 IO 有时候会比较慢，但是 Redis 使用的是 IO 多路复用机制，避免主线程一直处在等待网络连接或请求到来的状态，所以网络 IO 不是导致 Redis 阻塞的因素。键值对的增删改查操作是 Redis 和客户端交互的主要部分，也是 Redis 主线程执行的主要任务。所以复杂度高的增删改查操作肯定会阻塞 Redis。那么如何判断操作复杂度是不是高呢？有一个最基本的标准，就是看操作的复杂度是否为 O(N)。

Redis 中涉及集合的操作复杂度通常为 O(N)，要在使用时重视起来。例如集合元素全量查询操作 HGETALL、SMEMBERS，以及集合的聚合统计操作，例如求交、并和差集。这些操作可以作为 Redis 的第一个阻塞点：集合全量查询和聚合操作。

除此之外，集合自身的删除操作同样也有潜在的阻塞风险。可能会认为删除操作很简单，直接把数据删除即可，为什么还会阻塞主线程呢？其实删除操作的本质是要释放键值对占用的内存空间，不要小瞧内存的释放过程。释放内存只是第一步为了更加高效地管理内存空间，在应用程序释放内存时操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间而且会阻塞当前释放内存的应用程序，所以如果一下子释放大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞。

那么什么时候会释放大量内存呢？其实就是在删除大量键值对数据的时候，最典型的就是删除包含大量元素的集合，也称为 bigkey 删除。为了对 bigkey 的删除性能有一个直观的印象，下图列出不同元素数量的集合在进行删除操作时所消耗的时间，如下表所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/9ff922d683e74d2c8cf1f3c626d219a3.png)
从这张表里，我们可以得出三个结论：

 1. 当元素数量从 10 万增加到 100 万时，4 大集合类型的删除时间的增长幅度从 5 倍上升到近 20 倍；
 2. 集合元素越大，删除所花费的时间就越长；
 3. 当删除有 100 万个元素的集合时，最大的删除时间绝对值已经达到 1.98s（Hash 类型）。Redis 的响应时间一般在微秒级别，所以一个操作达到近 2s，不可避免地会阻塞主线程。

经过刚刚的分析，很显然 bigkey 删除操作就是 Redis 的第二个阻塞点。删除操作对 Redis 实例性能的负面影响很大，而且在实际业务开发时容易被忽略，所以一定要重视它。既然频繁删除键值对都是潜在的阻塞点，那么在 Redis 的数据库级别操作中，清空数据库（例如 FLUSHDB 和 FLUSHALL 操作）必然也是一个潜在的阻塞风险，因为它涉及到删除和释放所有的键值对。所以这就是 Redis 的第三个阻塞点：清空数据库。

2. 和磁盘交互时的阻塞点

之所以把 Redis 与磁盘的交互单独列为一类，主要是因为磁盘 IO 一般都是比较费时费力的，需要重点关注。幸运的是Redis 开发者早已认识到磁盘 IO 会带来阻塞，所以就把 Redis 进一步设计为采用子进程的方式生成 RDB 快照文件，以及执行 AOF 日志重写操作。这样一来这两个操作由子进程负责执行，慢速的磁盘 IO 就不会阻塞主线程。但是 Redis 直接记录 AOF 日志时会根据不同的写回策略对数据做落盘保存。一个同步写磁盘的操作的耗时大约是 1～2ms，如果有大量的写操作需要记录在 AOF 日志中，并同步写回的话就会阻塞主线程。这就得到 Redis 的第四个阻塞点：AOF 日志同步写。

3. 主从节点交互时的阻塞点

在主从集群中主库需要生成 RDB 文件，并传输给从库。主库在复制的过程中，创建和传输 RDB 文件都是由子进程来完成的不会阻塞主线程。但是对于从库来说，它在接收 RDB 文件后，需要使用 FLUSHDB 命令清空当前数据库，这就正好撞上刚才我们分析的第三个阻塞点。

此外从库在清空当前数据库后，还需要把 RDB 文件加载到内存，这个过程的快慢和 RDB 文件的大小密切相关，RDB 文件越大，加载过程越慢，所以加载 RDB 文件就成为 Redis 的第五个阻塞点。

4. 切片集群实例交互时的阻塞点

最后当在部署 Redis 切片集群时，每个 Redis 实例上分配的哈希槽信息需要在不同实例间进行传递，同时当需要进行负载均衡或者有实例增删时，数据会在不同的实例间进行迁移。不过哈希槽的信息量不大，而数据迁移是渐进式执行的，所以一般来说，这两类操作对 Redis 主线程的阻塞风险不大。

但是如果使用 Redis Cluster 方案，而且同时正好迁移的是 bigkey 的话就会造成主线程的阻塞，因为 Redis Cluster 使用同步迁移。当没有 bigkey 时切片集群的各实例在进行交互时不会阻塞主线程。来总结下刚刚找到的五个阻塞点：

 - 集合全量查询和聚合操作；
 - bigkey 删除；
 - 清空数据库；
 - AOF 日志同步写；
 - 从库加载 RDB 文件

如果在主线程中执行这些操作，必然会导致主线程长时间无法服务其他请求。为了避免阻塞式操作，Redis 提供异步线程机制。所谓的异步线程机制，就是指 Redis 会启动一些子线程，然后把一些任务交给这些子线程，让它们在后台完成，而不再由主线程来执行这些任务。使用异步线程机制执行操作可以避免阻塞主线程。不过此时问题是：这五大阻塞式操作都可以被异步执行吗？
# 哪些阻塞点可以异步执行
在分析阻塞式操作的异步执行的可行性之前，先来了解下异步执行对操作的要求。如果一个操作能被异步执行就意味着，它并不是 Redis 主线程的关键路径上的操作。再解释下关键路径上的操作，这就是说客户端把请求发送给 Redis 后等着 Redis 返回数据结果的操作。如下图所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/e649177dc3ab4653a14f8f9e50a80716.png)
主线程接收到操作 1 后，因为操作 1 并不用给客户端返回具体的数据，所以主线程可以把它交给后台子线程来完成，同时只要给客户端返回一个“OK”结果即可。在子线程执行操作 1 的时候，客户端又向 Redis 实例发送操作 2，而此时客户端是需要使用操作 2 返回的数据结果的，如果操作 2 不返回结果，那么客户端将一直处于等待状态。

在这个例子中，操作 1 就不算关键路径上的操作，因为它不用给客户端返回具体数据，所以可以由后台子线程异步执行。而操作 2 需要把结果返回给客户端，它就是关键路径上的操作，所以主线程必须立即把这个操作执行完。对于 Redis 来说读操作是典型的关键路径操作，因为客户端发送读操作之后，就会等待读取的数据返回，以便进行后续的数据处理。而 Redis 的第一个阻塞点“集合全量查询和聚合操作”都涉及到读操作，所以它们是不能进行异步操作。

再来看看删除操作。删除操作并不需要给客户端返回具体的数据结果，所以不算是关键路径操作。而刚才总结的第二个阻塞点“bigkey 删除”，和第三个阻塞点“清空数据库”，都是对数据做删除并不在关键路径上。因此可以使用后台子线程来异步执行删除操作。对于第四个阻塞点“AOF 日志同步写”来说，为了保证数据可靠性 Redis 实例需要保证 AOF 日志中的操作记录已经落盘，这个操作虽然需要实例等待但它并不会返回具体的数据结果给实例。所以也可以启动一个子线程来执行 AOF 日志的同步写，而不用让主线程等待 AOF 日志的写完成。

最后再来看下“从库加载 RDB 文件”这个阻塞点。从库要想对客户端提供数据存取服务，就必须把 RDB 文件加载完成。所以这个操作也属于关键路径上的操作，必须让从库的主线程来执行。对于 Redis 的五大阻塞点来说，除了“集合全量查询和聚合操作”和“从库加载 RDB 文件”，其他三个阻塞点涉及的操作都不在关键路径上，所以可以使用 Redis 的异步子线程机制来实现 bigkey 删除，清空数据库，以及 AOF 日志同步写。那么 Redis 实现的异步子线程机制具体是怎么执行呢？
# 异步的子线程机制
Redis 主线程启动后，会使用操作系统提供的 pthread_create 函数创建 3 个子线程，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行。主线程通过一个链表形式的任务队列和子线程进行交互。当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成。但实际上这个时候删除还没有执行，等到后台子线程从任务队列中读取任务后，才开始实际删除键值对并释放相应的内存空间。因此把这种异步删除也称为惰性删除（lazy free）。此时删除或清空操作不会阻塞主线程，这就避免对主线程的性能影响。和惰性删除类似当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到任务队列中。后台子线程读取任务后，开始自行写入 AOF 日志这样主线程就不用一直等待 AOF 日志写完。下图展示的是 Redis 中的异步子线程执行机制。
![在这里插入图片描述](https://img-blog.csdnimg.cn/1d575165f8634b47af19bd5170dea859.png)
需要注意的是，异步的键值对删除和数据库清空操作是 Redis 4.0 后提供的功能，Redis 也提供新的命令来执行这两个操作。

 - 键值对删除：当集合类型中有大量元素（例如有百万级别或千万级别元素）需要删除时，建议使用 UNLINK 命令。
 - 清空数据库：可以在 FLUSHDB 和 FLUSHALL 命令后加上 ASYNC 选项，这样就可以让后台子线程异步地清空数据库，如下所示：
```java
FLUSHDB ASYNC
FLUSHALL AYSNC
```

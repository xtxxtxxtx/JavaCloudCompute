# 消息队列消息存取需求
消息队列存取消息过程：分布式系统中，当两个组件要基于消息队列进行通信时，一个组件会把要处理的数据以消息的形式传递给消息队列，然后该组件就可以继续执行其他操作；远端另一个组件从消息队列中把消息读取出来，再在本地进行处理。

假设组件1需要对采集到的数据进行求和计算并写入数据库，但是消息到达的速度很快，组件1没有办法及时的既做采集，又做计算，并且写入数据库。所以可以使用基于消息队列的通信，让组件1把数据x和y保存为json格式的消息再发到消息队列，这样就可以继续接收新的数据。组件2则异步的从消息队列中把数据读取出来，在服务器2上进行求和计算，再写入数据库。此过程如下图所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/808f56e8da484cfb893b7371e5526f06.png)
一般吧消息队列中发送消息的组件称为生产者（例子中的组件1），把接收消息的组件称为消费者（例子中的组件2），下图展示的是一个通用的消息队列的架构模型：
![在这里插入图片描述](https://img-blog.csdnimg.cn/1960ea9ed24145e087bb3801c4aeae45.png)
在使用消息队列时消费者可以异步读取生产者消息，然后再进行处理。这样即使生产者发送消息的速度远远超过消费者处理消息的速度，生产者已经发送的消息可以缓存在消息队列中避免阻塞生产者，这是消息队列作为分布式组件通信的一个优势。

**不过消息队列在存取消息时必须满足三个需求，分别是消息保序、处理重复的消息和保证消息可靠性。**

## 需求一：消息保序
虽然消费者是异步处理消息，但是消费者仍然需要按照生产者发送消息的顺序来处理消息，避免后发送的消息被先处理。对于要求消息保序的场景来说一旦出现这种消息被乱序处理的情况，就可能会导致业务逻辑被错误执行，从而给业务方造成损失。看一个更新商品库存的场景，假设生产者负责接收库存更新请求，消费者负责实际更新库存，现有库存量是 10。生产者先后发送消息 1 和消息 2，消息 1 要把商品 X 的库存记录更新为 5，消息 2 是把商品 X 库存更新为 3。如果消息 1 和 2 在消息队列中无法保序，出现消息 2 早于消息 1 被处理的情况，那么很显然库存更新就出错。这是业务应用无法接受的。

面对这种情况，会想到一种解决方案：不要把更新后的库存量作为生产者发送的消息，而是把库存扣除值作为消息的内容。这样一来消息 1 是扣减库存量 5，消息 2 是扣减库存量 2。如果消息 1 和消息 2 之间没有库存查询请求的话，即使消费者先处理消息 2，再处理消息 1，这个方案也能够保证最终的库存量是正确的，也就是库存量为 3。但是还需要考虑这样一种情况：假如消费者收到这样三条消息：消息 1 是扣减库存量 5，消息 2 是读取库存量，消息 3 是扣减库存量 2，此时如果消费者先处理了消息 3（把库存量扣减 2），那么库存量就变成了 8。然后消费者处理消息 2，读取当前的库存量是 8，这就会出现库存量查询不正确的情况。从业务应用层面看，消息 1、2、3 应该是顺序执行的，所以消息 2 查询到的应该是扣减 5 以后的库存量，而不是扣减 2 以后的库存量。所以用库存扣除值作为消息的方案，在消息中同时包含读写操作的场景下，会带来数据读取错误的问题。而且该方案还会面临一个问题，那就是重复消息处理。
## 需求二：重复消息处理
消费者从消息队列读取消息时，有时会因为网络堵塞而出现消息重传的情况。此时消费者可能会收到多条重复的消息。对于重复的消息，消费者如果多次处理的话，就可能造成一个业务逻辑被多次执行，如果业务逻辑正好是要修改数据，那就会出现数据被多次修改的问题。以库存更新为例，假设消费者收到一次消息 1，要扣减库存量 5，然后又收到一次消息 1，那么如果消费者无法识别这两条消息实际是一条相同消息的话，就会执行两次扣减库存量 5 的操作，此时库存量就会出现错误。这当然也是无法接受的。
## 需求三：消息可靠性保证
另外消费者在处理消息的时候，还可能出现因为故障或宕机导致消息没有处理完成的情况。此时消息队列需要能提供消息可靠性的保证，也就是说当消费者重启后，可以重新读取消息再次进行处理，否则就会出现消息漏处理的问题。Redis 的 List 和 Streams 两种数据类型，就可以满足消息队列的这三个需求。
## 基于List消息队列解决方案
List 本身是按照先进先出顺序对数据进行存取的，因此如果使用 List 作为消息队列保存消息的话就已经能满足消息保序的需求。具体来说生产者可使用LPUSH命令把要发送的消息依次写入 List，而消费者则可使用 RPOP命令，从List的另一端按照消息的写入顺序，依次读取消息并进行处理。如下图所示生产者用LPUSH写入两条库存消息，分别是5和3表示要把库存更新为5和3；消费者则用RPOP把两条消息依次读出，然后进行相应的处理。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2d9348db05bf46b08e38110d57befc9e.png)
但是在消费者读取数据时有一个潜在的性能风险点。在生产者往List写入数据时List并不会主动通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 RPOP 命令（比如使用一个 while(1) 循环）。如果有新消息写入RPOP 命令就会返回结果，否则RPOP 命令返回空值再继续循环。所以即使没有新消息写入 List，消费者也要不停地调用 RPOP 命令，这就会导致消费者程序的 CPU 一直消耗在执行 RPOP 命令上带来不必要的性能损失。为了解决这个问题Redis 提供了 BRPOP 命令。BRPOP 命令也称为阻塞式读取，客户端在没有读到队列数据时自动阻塞，直到有新的数据写入队列，再开始读取新数据。和消费者程序自己不停地调用 RPOP 命令相比，这种方式能节省 CPU 开销。

消息保序的问题解决，还需要考虑解决重复消息处理的问题，其实有一个要求：消费者程序本身能对重复消息进行判断。一方面消息队列要能给每一个消息提供全局唯一的 ID 号；另一方面消费者程序要把已经处理过的消息的 ID 号记录下来。当收到一条消息后消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。如果已经处理过那么消费者程序就不再进行处理。这种处理特性也称为幂等性，幂等性就是指对于同一条消息，消费者收到一次的处理结果和收到多次的处理结果是一致的。不过List 本身是不会为每个消息生成 ID 号的，所以消息的全局唯一 ID 号就需要生产者程序在发送消息前自行生成。生成之后在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。例如执行以下命令，就把一条全局 ID 为 101030001、库存量为 5 的消息插入了消息队列：
```java
LPUSH mq "101030001:stock:5"
(integer) 1
```
最后再来看下，List 类型是如何保证消息可靠性的。当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息。所以如果消费者程序在处理消息的过程出现故障或宕机，就会导致消息没有处理完成，那么消费者程序再次启动后就没法再次从 List 中读取消息。为了留存消息List 类型提供 BRPOPLPUSH 命令，这个命令的作用是让消费者程序从一个 List 中读取消息，同时Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存。这样一来如果消费者程序读消息但没能正常处理，等它重启后就可以从备份 List 中重新读取消息并进行处理。如下图展示的是 BRPOPLPUSH 命令留存消息，以及消费者再次读取消息的过程。
![在这里插入图片描述](https://img-blog.csdnimg.cn/91dcbb889a334ec4b6ab7eeb8d7e14de.png)
生产者先用 LPUSH 把消息“5”“3”插入到消息队列 mq 中，消费者程序使用 BRPOPLPUSH 命令读取消息“5”，同时消息“5”还会被 Redis 插入到 mqback 队列中。如果消费者程序处理消息“5”时宕机，等它重启后可以从 mqback 中再次读取消息“5” 继续处理。基于 List 类型可以满足分布式组件对消息队列的三大需求。但是在用 List 做消息队列时，还可能遇到一个问题：生产者消息发送很快，而消费者处理消息的速度比较慢，会导致 List 中的消息越积越多，给 Redis 的内存带来很大压力。此时希望启动多个消费者程序组成一个消费组，一起分担处理 List 中的消息。但是 List 类型并不支持消费组的实现。到 Redis 从 5.0 版本开始提供的 Streams 数据类型。和 List 相比 Streams 同样能够满足消息队列的三大需求。而且还支持消费组形式的消息读取。
## 基于Streams消息队列解决方案
Streams 是 Redis 专门为消息队列设计的数据类型，提供丰富的消息队列操作命令。

 - XADD：插入消息，保证有序，可以自动生成全局唯一 ID；
 - XREAD：用于读取消息，可以按 ID 读取数据；
 - XREADGROUP：按消费组形式读取消息；
 - XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。

XADD 命令可以往消息队列中插入新消息，消息的格式是键 - 值对形式。对于插入的每一条消息 Streams 可以自动为其生成一个全局唯一的 ID。比如说执行下面的命令，就可以往名称为 mqstream 的消息队列中插入一条消息，消息的键是 repo，值是 5。其中消息队列名称后面的*，表示让 Redis 为插入的数据自动生成一个全局唯一的 ID，例如“1599203861727-0”。当然也可以不使用*，直接在消息队列名称后自行设定一个 ID 号，只要保证这个 ID 号是全局唯一的即可。不过相比自行设定 ID 号，使用*会更加方便高效。
```java
XADD mqstream * repo 5
"1599203861727-0"
```
可以看到消息的全局唯一 ID 由两部分组成，第一部分“1599203861727”是数据插入时，以毫秒为单位计算的当前服务器时间，第二部分表示插入消息在当前毫秒内的消息序号，这是从 0 开始编号的。例如 “1599203861727-0”就表示在“1599203861727”毫秒内的第 1 条消息。当消费者需要读取消息时可以直接使用 XREAD 命令从消息队列中读取。XREAD 在读取消息时可以指定一个消息 ID，并从这个消息 ID 的下一条消息开始进行读取。例如可以执行下面的命令，从 ID 号为 1599203861727-0 的消息开始，读取后续的所有消息（示例中一共 3 条）。
```java
XREAD BLOCK 100 STREAMS  mqstream 1599203861727-0
1) 1) "mqstream"
   2) 1) 1) "1599274912765-0"
         2) 1) "repo"
            2) "3"
      2) 1) "1599274925823-0"
         2) 1) "repo"
            2) "2"
      3) 1) "1599274927910-0"
         2) 1) "repo"
            2) "1"
```
另外消费者也可以在调用 XRAED 时设定 block 配置项，实现类似于 BRPOP 的阻塞读取操作。当消息队列中没有消息时一旦设置 block 配置项，XREAD 就会阻塞，阻塞的时长可以在 block 配置项进行设置。举例来看一下下面的命令，其中命令最后的“$”符号表示读取最新的消息，同时设置了 block 10000 的配置项，10000 的单位是毫秒，表明 XREAD 在读取最新消息时如果没有消息到来，XREAD 将阻塞 10000 毫秒（即 10 秒），然后再返回。下面命令中的 XREAD 执行后消息队列 mqstream 中一直没有消息，所以XREAD 在 10 秒后返回空值（nil）。
```java
XREAD block 10000 streams mqstream $
(nil)
(10.00s)
```
Streams 本身可以使用 XGROUP 创建消费组，创建消费组之后 Streams 可以使用 XREADGROUP 命令让消费组内的消费者读取消息，例如执行下面的命令，创建一个名为 group1 的消费组，此消费组消费的消息队列是 mqstream。
```java
XGROUP create mqstream group1 0
OK
```
然后再执行一段命令，让 group1 消费组里的消费者 consumer1 从 mqstream 中读取所有消息，其中命令最后的参数“>”，表示从第一条尚未被消费的消息开始读取。因为在 consumer1 读取消息前，group1 中没有其他消费者读取过消息，所以 consumer1 就得到 mqstream 消息队列中的所有消息（一共 4 条）。
```java
XREADGROUP group group1 consumer1 streams mqstream >
1) 1) "mqstream"
   2) 1) 1) "1599203861727-0"
         2) 1) "repo"
            2) "5"
      2) 1) "1599274912765-0"
         2) 1) "repo"
            2) "3"
      3) 1) "1599274925823-0"
         2) 1) "repo"
            2) "2"
      4) 1) "1599274927910-0"
         2) 1) "repo"
            2) "1"
```
需要注意的是，消息队列中的消息一旦被消费组里的一个消费者读取，就不能再被该消费组内的其他消费者读取。比如说当执行完刚才的 XREADGROUP 命令后，再执行下面的命令，让 group1 内的 consumer2 读取消息时，consumer2 读到的就是空值，因为消息已经被 consumer1 读取完成，如下所示：
```java
XREADGROUP group group1 consumer2  streams mqstream 0
1) 1) "mqstream"
   2) (empty list or set)
```
使用消费组的目的是让组内的多个消费者共同分担读取消息，所以通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。例如执行下列命令，让 group2 中的 consumer1、2、3 各自读取一条消息。
```java
XREADGROUP group group2 consumer1 count 1 streams mqstream >
1) 1) "mqstream"
   2) 1) 1) "1599203861727-0"
         2) 1) "repo"
            2) "5"

XREADGROUP group group2 consumer2 count 1 streams mqstream >
1) 1) "mqstream"
   2) 1) 1) "1599274912765-0"
         2) 1) "repo"
            2) "3"

XREADGROUP group group2 consumer3 count 1 streams mqstream >
1) 1) "mqstream"
   2) 1) 1) "1599274925823-0"
         2) 1) "repo"
            2) "2"
```
为了保证消费者在发生故障或宕机再次重启后仍然可以读取未处理完的消息，Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令通知 Streams“消息已经处理完成”。如果消费者没有成功处理消息它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时消费者可以在重启后用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。例如来查看一下 group2 中各个消费者已读取、但尚未确认的消息个数。其中 XPENDING 返回结果的第二、三行分别表示 group2 中所有消费者读取的消息最小 ID 和最大 ID。
```java
XPENDING mqstream group2
1) (integer) 3
2) "1599203861727-0"
3) "1599274925823-0"
4) 1) 1) "consumer1"
      2) "1"
   2) 1) "consumer2"
      2) "1"
   3) 1) "consumer3"
      2) "1"
```
如果还需要进一步查看某个消费者具体读取哪些数据，可以执行下面的命令：
```java
XPENDING mqstream group2 - + 10 consumer2
1) 1) "1599274912765-0"
   2) "consumer2"
   3) (integer) 513336
   4) (integer) 1
```
可以看到 consumer2 已读取的消息的 ID 是 1599274912765-0。一旦消息 1599274912765-0 被 consumer2 处理，consumer2 就可以使用 XACK 命令通知 Streams，然后这条消息就会被删除。当再使用 XPENDING 命令查看时就可以看到 consumer2 已经没有已读取、但尚未确认处理的消息。
```java
 XACK mqstream group2 1599274912765-0
(integer) 1
XPENDING mqstream group2 - + 10 consumer2
(empty list or set)
```
现在知道使用 Streams 实现消息队列的方法，Streams 是 Redis 5.0 专门针对消息队列场景设计的数据类型，如果 Redis 是 5.0 及 5.0 以后的版本，就可以考虑把 Streams 用作消息队列。

总结：
![在这里插入图片描述](https://img-blog.csdnimg.cn/fbf6e585c3ae454cb701bd7054a7fec7.png)


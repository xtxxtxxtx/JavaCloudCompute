在使用 Redis 时会遇到这样一个问题：进行数据删除后，数据量已经很少，但是使用 top 命令查看时还会发现 Redis 占用了很多内存。实际上是因为当数据删除后 Redis 释放的内存空间会由内存分配器管理，并不会立即返回给操作系统。所以操作系统仍然会记录着给 Redis 分配大量内存。但是这会伴随一个潜在的风险点：Redis 释放的内存空间可能并不是连续的，那么这些不连续的内存空间很有可能处于一种闲置的状态。这就会导致一个问题：虽然有空闲空间 Redis 却无法用来保存数据，不仅会减少 Redis 能够实际保存的数据量，还会降低 Redis 运行机器的成本回报率。

可以把 Redis 的内存空间比作高铁上的车厢座位数，如果高铁的车厢座位数很多，但运送的乘客数很少，那么高铁运行一次的效率低，成本高性价比就会降低，Redis 也是一样。如果正好租用一台 16GB 内存的云主机运行 Redis，但是却只保存 8GB 的数据，那么租用这台云主机的成本回报率也会降低一半，这个结果肯定不是想要的。
# 什么是内存碎片
通常情况下内存空间闲置，往往是因为操作系统发生较为严重的内存碎片。假设一个车厢的座位总共有 60 个，现在已经卖 57 张票，和 2 个小伙伴要乘坐高铁出门旅行，刚好需要三张票。不过想要坐在一起，这样可以在路上聊天。但是在选座位时却发现，已经买不到连续的座位，于是只好换了一趟车。这样一来需要改变出行时间，而且这趟车就空置了三个座位。其实这趟车的空座位是和你们的人数相匹配的，只是这些空座位是分散的，如下图所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/ded0baa1f51245aeb072bf1f10e80d67.png)
可以把这些分散的空座位叫作“车厢座位碎片”，知道这一点操作系统的内存碎片就很容易理解。虽然操作系统的剩余内存空间总量足够，但是应用申请的是一块连续地址空间的 N 字节，但在剩余的内存空间中没有大小为 N 字节的连续空间，那么这些剩余空间就是内存碎片（比如上图中的“空闲 2 字节”和“空闲 1 字节”，就是这样的碎片）。那么 Redis 中的内存碎片是什么原因导致，只有了解内存碎片的成因才能对症下药，把 Redis 占用的内存空间充分利用起来，增加存储的数据量。
# 内存碎片是如何形成的
其实内存碎片的形成有内因和外因两个层面的原因。简单来说内因是操作系统的内存分配机制，外因是 Redis 的负载特征。
## 内因：内存分配器的分配策略
内存分配器的分配策略决定操作系统无法做到“按需分配”。这是因为内存分配器一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配。Redis 可以使用 libc、jemalloc、tcmalloc 多种内存分配器来分配内存，默认使用 jemalloc。接下来以 jemalloc 为例，来具体解释一下。其他分配器也存在类似的问题。

jemalloc 的分配策略之一，是按照一系列固定的大小划分内存空间，例如 8 字节、16 字节、32 字节、48 字节，…, 2KB、4KB、8KB 等。当程序申请的内存最接近某个固定值时，jemalloc 会给它分配相应大小的空间，这样的分配方式本身是为了减少分配次数。例如 Redis 申请一个 20 字节的空间保存数据，jemalloc 就会分配 32 字节，此时如果应用还要写入 10 字节的数据，Redis 就不用再向操作系统申请空间，因为刚才分配的 32 字节已经够用，这就避免一次分配操作。但是如果 Redis 每次向分配器申请的内存空间大小不一样，这种分配方式就会有形成碎片的风险，而这正好来源于 Redis 的外因。
## 外因：键值对大小不一样和删改操作
Redis 通常作为共用的缓存系统或键值数据库对外提供服务，所以不同业务应用的数据都可能保存在 Redis 中，这就会带来不同大小的键值对。这样一来 Redis 申请内存空间分配时，本身就会有大小不一的空间需求，这是第一个外因。但是内存分配器只能按固定大小分配内存，所以分配的内存空间一般都会比申请的空间大一些，不会完全一致，这本身就会造成一定的碎片降低内存空间存储效率。比如说应用 A 保存 6 字节数据，jemalloc 按分配策略分配 8 字节。如果应用 A 不再保存新数据，那么这里多出来的 2 字节空间就是内存碎片，如下图所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/7bbf60ba59894b98bdd26a550d813271.png)
第二个外因是这些键值对会被修改和删除，这会导致空间的扩容和释放。具体来说一方面，如果修改后的键值对变大或变小就需要占用额外的空间或者释放不用的空间。另一方面删除的键值对就不再需要内存空间，此时就会把空间释放出来形成空闲空间。
![在这里插入图片描述](https://img-blog.csdnimg.cn/6be70b56aa394f34934f0941ccda06c8.png)
一开始应用 A、B、C、D 分别保存 3、1、2、4 字节的数据，并占据相应的内存空间。然后应用 D 删除 1 个字节，这个 1 字节的内存空间就空出来。紧接着应用 A 修改数据，从 3 字节变成 4 字节。为了保持 A 数据的空间连续性，操作系统就需要把 B 的数据拷贝到别的空间，比如拷贝到 D 刚刚释放的空间中。此时应用 C 和 D 也分别删除 2 字节和 1 字节的数据，整个内存空间上就分别出现 2 字节和 1 字节的空闲碎片。如果应用 E 想要一个 3 字节的连续空间，显然是不能得到满足的。因为虽然空间总量够，但却是碎片空间并不是连续的。其中内存分配器策略是内因，而 Redis 的负载属于外因，包括大小不一的键值对和键值对修改删除带来的内存空间变化。大量内存碎片的存在会造成 Redis 的内存实际利用率变低，
# 如何判断是否有内存碎片
Redis 是内存数据库，内存利用率的高低直接关系到 Redis 运行效率的高低。为了让用户能监控到实时的内存使用情况 Redis 自身提供 INFO 命令可以用来查询内存使用的详细信息，命令如下：
```java
INFO memory
# Memory
used_memory:1073741736
used_memory_human:1024.00M
used_memory_rss:1997159792
used_memory_rss_human:1.86G
…
mem_fragmentation_ratio:1.86
```
这里有一个 mem_fragmentation_ratio 的指标，它表示的就是 Redis 当前的内存碎片率。那么这个碎片率是怎么计算的。其实就是上面的命令中的两个指标 used_memory_rss 和 used_memory 相除的结果。
```java
mem_fragmentation_ratio = used_memory_rss/ used_memory
```
used_memory_rss 是操作系统实际分配给 Redis 的物理内存空间，里面就包含碎片；而 used_memory 是 Redis 为了保存数据实际申请使用的空间。例如 Redis 申请使用了100 字节（used_memory），操作系统实际分配 128 字节（used_memory_rss），此时 mem_fragmentation_ratio 就是 1.28。

 - mem_fragmentation_ratio 大于 1 但小于 1.5，这种情况是合理的。这是因为毕竟内因的内存分配器是一定要使用的，分配策略都是通用的不会轻易修改；而外因由 Redis 负载决定，也无法限制。所以存在内存碎片也是正常的。
 - mem_fragmentation_ratio 大于 1.5 。这表明内存碎片率已经超过 50%。一般情况下需要采取一些措施来降低内存碎片率。
# 如何清理内存碎片
当 Redis 发生内存碎片后，一个“简单粗暴”的方法就是重启 Redis 实例。当然这并不是一个“优雅”的方法，毕竟重启 Redis 会带来两个后果：
 - 如果 Redis 中的数据没有持久化，那么，数据就会丢失；
 - 即使 Redis 数据持久化，还需要通过 AOF 或 RDB 进行恢复，恢复时长取决于 AOF 或 RDB 的大小，如果只有一个 Redis 实例，恢复阶段无法提供服务。

从 4.0-RC3 版本以后，Redis 自身提供一种内存碎片自动清理的方法，先来看这个方法的基本机制。内存碎片清理简单来说，就是“搬家让位，合并空间”。还以刚才的高铁车厢选座为例来解释一下，和小伙伴不想耽误时间，所以直接买了座位不在一起的三张票。但是上车后和小伙伴通过和别人调换座位又坐到一起，这么一说碎片清理的机制就很容易理解。当有数据把一块连续的内存空间分割成好几块不连续的空间时，操作系统就会把数据拷贝到别处。此时数据拷贝需要能把这些数据原来占用的空间都空出来，把原本不连续的内存空间变成连续的空间。否则如果数据拷贝后，并没有形成连续的内存空间，这就不能算是清理。
![在这里插入图片描述](https://img-blog.csdnimg.cn/25a09acd02234099ba850cbb81a44228.png)
在进行碎片清理前，这段 10 字节的空间中分别有 1 个 2 字节和 1 个 1 字节的空闲空间，只是这两个空间并不连续。操作系统在清理碎片时，会先把应用 D 的数据拷贝到 2 字节的空闲空间中并释放 D 原先所占的空间。然后再把 B 的数据拷贝到 D 原来的空间中。这样一来这段 10 字节空间的最后三个字节就是一块连续空间。到这里。碎片清理结束。不过需要注意的是：碎片清理是有代价的，操作系统需要把多份数据拷贝到新位置，把原有空间释放出来，这会带来时间开销。因为 Redis 是单线程在数据拷贝时，Redis 只能等着，这就导致 Redis 无法及时处理请求，性能就会降低。而且有的时候，数据拷贝还需要注意顺序，就像刚刚说的清理内存碎片的例子，操作系统需要先拷贝 D，并释放 D 的空间后，才能拷贝 B。这种对顺序性的要求，会进一步增加 Redis 的等待时间，导致性能降低。

那么可以尽量缓解这个问题吗？这就要提到 Redis 专门为自动内存碎片清理功机制设置的参数。可以通过设置参数来控制碎片清理的开始和结束时机，以及占用的 CPU 比例，从而减少碎片清理对 Redis 本身请求处理的性能影响。首先Redis 需要启用自动内存碎片清理，可以把 activedefrag 配置项设置为 yes，命令如下：
```java
config set activedefrag yes
```
这个命令只是启用自动清理功能，但是具体什么时候清理，会受到下面这两个参数的控制。这两个参数分别设置触发内存清理的一个条件，如果同时满足这两个条件就开始清理。在清理的过程中只要有一个条件不满足，就停止自动清理。

 - active-defrag-ignore-bytes 100mb：表示内存碎片的字节数达到 100MB 时，开始清理；
 - active-defrag-threshold-lower 10：表示内存碎片空间占操作系统分配给 Redis 的总空间比例达到 10% 时，开始清理。

为了尽可能减少碎片清理对 Redis 正常请求处理的影响，自动内存碎片清理功能在执行时，还会监控清理操作占用的 CPU 时间，而且还设置两个参数分别用于控制清理操作占用的 CPU 时间比例的上、下限，既保证清理工作能正常进行，又避免降低 Redis 性能。这两个参数具体如下：

 - active-defrag-cycle-min 25： 表示自动清理过程所用 CPU 时间的比例不低于 25%，保证清理能正常开展；
 - active-defrag-cycle-max 75：表示自动清理过程所用 CPU 时间的比例不高于 75%，一旦超过，就停止清理，从而避免在清理时，大量的内存拷贝阻塞 Redis，导致响应延迟升高。

自动内存碎片清理机制在控制碎片清理启停的时机上，既考虑碎片的空间占比、对 Redis 内存使用效率的影响，还考虑清理机制本身的 CPU 时间占比、对 Redis 性能的影响。而且清理机制还提供 4 个参数，可以根据实际应用中的数据量需求和性能要求灵活使用。

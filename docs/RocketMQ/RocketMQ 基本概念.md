# 1 介绍
RocketMQ是一款纯java、分布式、队列模型的开源消息中间件，支持事务消息、顺序消息、批量消息、定时消息、消息回溯等。
## 1.1 RocketMQ 特点

 1. 支持发布订阅(Pub/Sub)和点对点(P2P)消息模型
 2. 在一个队列中可靠的先进先出(FIFO)和严格的顺序传递(RocketMQ可保证严格消息顺序，而ActiveMQ无法保证)
 3. 支持pull和push两种消息模式

> pull是消费者主动从MQ拉取消息，push是MQ给消费者推送消息，但RocketMQ的push其实是基于pull实现的。
> 是先由一个业务代码从MQ中pull消息，再由业务代码push给特定的消费者，其底层就是pull模式。

 - 单一队列百万消息堆积能力(RocketMQ提供亿级消息堆积能力，但其依然可保证写入低延迟)
 - 支持多种消息协议，如JMS、MQTT等
 - 分布式高可用部署架构，满足至少一次消息传递语义
 - 提供docker镜像用于隔离测试和云集群部署
 - 提供配置、指标和监控等功能丰富的dashboard
## 1.2 优势
目前主流的MQ主要是RocketMQ、Kafka、RabbitMQ，其主要优势是：
 - 支持事务性消息(消息发送和DB操作保持两方最终一致性，其余两个不支持)
 - 支持结合RocketMQ多个系统之间数据最终一致性(多方事务，二方事务是前提)
 - 支持18个级别的延迟消息(Kafka不支持)
 - 支持指定次数和时间间隔的失败消息重发(Kafka不支持，RabbitMQ需要手动确认)
 - 支持Consumer端Tag过滤，减少不必要网络传输(即过滤由MQ完成，而不是由消费者完成。其余两个不支持)
 - 支持重复消费(Kafka支持)
# 2 RocketMQ基本概念
RocketMQ主要有四大核心组成部分：NameServer、Broker、Producer和Consumer四个部分。
## 2.1 NameServer
NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。
NameServer是整个RocketMQ的大脑，它是RocketMQ的服务注册中心，因此RocketMQ需要先启动NameServer再启动Rocket中的Broker。
### 2.1.1 NameServer作用
名称服务器用来保存Broker相关元信息并给Producer和Consumer查找Broker信息。NameServer被设计成几乎无状态的，可横向扩展，节点之间相互之间无通信，通过部署多台机器来标记自己是一个伪集群。

每个Broker在启动时候会到NameServer注册，Producer在发送消息前会根据Topic到NameServer获取到Broker的路由信息，进而和Broker取得连接。Consumer也会定时获取Topic的路由信息。所以从功能上看应该是和Zookeeper差不多，早期RocketMQ版本使用的是Zookeeper，后来改为自己实现NameServer。
### 2.1.2 和zk区别
NameServer和ZK作用大致是相同的，从宏观上看NameServer做的东西很少，就是保存一些运行数据，NameServer之间不互连，这就需要Broker端连接所有的NameServer，运行数据的改动要发送到每一个NameServer来保证运行数据的一致性(一致性较弱)，因此NameServer很轻量级，但是Broker端就要做更多的东西。

而Zookeeper，Broker只需要连接其中的一台机器，运行数据分发、一致性都交给Zookeeper完成。
### 2.1.3 高可用保障
Broker在启动时向所有NameServer注册(主要是服务器地址等)，生产者在发送消息之前先从NameServer获取Broker服务器地址列表(消费者一样)，然后根据负载均衡算法从列表中选择一台服务器进行消息发送。

NameServer与每台Broker服务保持长连接，并间隔30s检查Broker是否存活，如果检测到Broker宕机，则从路由注册表中将其移除，这样就可以实现RocketMQ的高可用。
## 2.2 Broker
消息服务器(Broker)是消息存储中心，主要作用是接收来自Producer的消息并存储，Consumer从这里取得消息。它还存储与消息相关的元数据，包括用户组、消费进度偏移量、队列消息等。从部署结构图中可以看出Broker有Master和Slave两种类型，Master既可写又可读，Slave只可读。
### 2.2.1 部署方式
broker部署相对复杂，broker分为master和slave，一个master可以对应多个slave，但是一个slave只能对应一个master，master和slave对应关系通过指定相同的broker name，不同的brokerId来定义，brokerId为0表示master，非0表示slave。master可以部署多个。
#### 2.2.1.1 单master
一旦broker重启或者宕机会导致整个服务不可用，这种方式风险较大，因此不建议线上环境使用。
#### 2.2.1.2 多master
所有消息服务器都是master，没有slave。这种方式优点是配置简单，单个master宕机或者重启维护对应用都无影响。缺点是单台机器宕机期间，该机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受影响。
#### 2.2.1.3 多master多slave(异步复制)
每个master配置一个slave，所以有多对master-slave，消息采用异步复制方式，主备之间有毫秒级消息延迟。这种方式优点是消息丢失的非常少，且消息实时性不会受影响，Master 宕机后消费者可以继续从 Slave 消费，中间的过程对用户应用程序透明，不需要人工干预，性能同多 Master 方式几乎一样。缺点是 Master 宕机时在磁盘损坏情况下会丢失极少量消息。
#### 2.2.1.4 多master多slave(同步双写)
每个 Master 配置一个 Slave，所以有多对 Master-Slave ，消息采用同步双写方式，主备都写成功才返回成功。这种方式优点是数据与服务都没有单点问题，Master 宕机时消息无延迟，服务与数据的可用性非常高。缺点是性能相对异步复制方式略低，发送消息的延迟会略高。
### 2.2.2 高可用保障
每个broker与NameServer集群中的所有节点建立长连接，定时(每隔30s)注册topic信息到所有NameServer。NameServer定时(每隔10s)会扫描所有存活broker的连接，如果NameServer超过2分钟没有收到心跳，则NameServer断开与Broker的连接。
## 2.3 Producer
也称消息发布者，负责生产并发送消息到topic。
生产者向brokers发送由业务应用程序系统生成的消息。RocketMQ提供了发送：同步、异步和单向的多种范例。
### 2.3.1 同步发送
同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。
### 2.3.2 异步发送
异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。假如过一段时间检测到某个信息发送失败，可以选择重新发送。
### 2.3.3 单向发送
单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。
### 2.3.4 生产者组
生产者组（Producer Group）是一类 Producer 的集合，这类 Producer 通常发送一类消息并且发送逻辑一致，所以将这些 Producer 分组在一起。从部署结构上看生产者通过 Producer Group 的名字来标记自己是一个集群。
### 2.3.5 高可用保障
Producer与Name Server集群中的其中一个节点(随机选择)建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。

Producer每隔30s（由ClientConfig的pollNameServerInterval）从Name server获取所有topic队列的最新情况，这意味着如果Broker不可用，Producer最多30s能够感知，在此期间内发往Broker的所有消息都会失败。

Producer每隔30s（由ClientConfig中heartbeatBrokerInterval决定）向所有关联的broker发送心跳，Broker每隔10s中扫描所有存活的连接，如果Broker在2分钟内没有收到心跳数据，则关闭与Producer的连接。
## 2.4 Consumer
也称为消息订阅者，负责从 Topic 接收并消费消息。
消费者从brokers那里拉取信息并将其输入应用程序。
### 2.4.1 消费者组
消费者组（Consumer Group）一类 Consumer 的集合名称，这类 Consumer 通常消费同一类消息并且消费逻辑一致，所以将这些 Consumer 分组在一起。消费者组与生产者组类似，都是将相同角色的分组在一起并命名。

RocketMQ中的消息有个特点，同一条消息，只能被某一消费组其中的一台机器消费，但是可以同时被不同的消费组消费。
![请添加图片描述](https://img-blog.csdnimg.cn/434aded75e1d447aa9328a463d921932.png)

> 例如图中的消息就只能被A中的某一台机器消费，但是同时也可以被B中的某一台机器消费

### 2.4.2 高可用保障
Consumer与Name Server集群中的其中一个节点(随机选择)建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。

Consumer每隔30s从Name server获取topic的最新队列情况，这意味着Broker不可用时，Consumer最多最需要30s才能感知。

Consumer每隔30s（由ClientConfig中heartbeatBrokerInterval决定）向所有关联的broker发送心跳，Broker每隔10s扫描所有存活的连接，若某个连接2分钟内没有发送心跳数据，则关闭连接；并向该Consumer Group的所有Consumer发出通知，Group内的Consumer重新分配队列，然后继续消费。

当Consumer得到master宕机通知后，转向slave消费，slave不能保证master的消息100%都同步过来了，因此会有少量的消息丢失。但是一旦master恢复，未同步过去的消息会被最终消费掉。
## 2.5 运转流程
![请添加图片描述](https://img-blog.csdnimg.cn/f4a5119a94384533aa53fbb8a557f18b.png)

 1. NameServer先启动
 2. Broker启动时向NameServer注册
 3. 生产者在发送某个主题的消息之前先从 NamerServer 获取 Broker 服务器地址列表（有可能是集群），然后根据负载均衡算法从列表中选择一台Broker 进行消息发送
 4. NameServer 与每台 Broker 服务器保持长连接，并间隔 30S 检测 Broker 是否存活，如果检测到Broker 宕机（使用心跳机制， 如果检测超120S），则从路由注册表中将其移除
 5. 消费者在订阅某个主题的消息之前从 NamerServer 获取 Broker 服务器地址列表（有可能是集群），但是消费者选择从 Broker 中 订阅消息，订阅规则由 Broker 配置决定
## 2.6 名词解释
### 消息
消息（Message）就是要传输的信息。一条消息必须有一个主题（Topic），主题可以看做是你的信件要邮寄的地址。一条消息也可以拥有一个可选的标签（Tag）和额处的键值对，它们可以用于设置一个业务 key 并在 Broker 上查找此消息以便在开发期间查找问题
### 主题
主题（Topic）可以看做消息的规类，它是消息的第一级类型。比如一个电商系统可以分为：交易消息、物流消息等，一条消息必须有一个 Topic 。

Topic 与生产者和消费者的关系非常松散，一个 Topic可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。一个Topic 也可以被 0个、1个、多个消费者订阅。
### 标签
标签（Tag）可以看作子主题，它是消息的第二级类型，用于为用户提供额外的灵活性。使用标签，同一业务模块不同目的的消息就可以用相同 Topic 而不同的 Tag 来标识。
比如交易消息又可以分为：交易创建消息、交易完成消息等，一条消息可以没有 Tag 。标签有助于保持您的代码干净和连贯，并且还可以为 RocketMQ 提供的查询系统提供帮助。

简单来说TOPIC可以看作衣服，而TAG可以看作衣服下的【短袖】、【外套】、【卫衣】等。
### 消息队列
消息队列(Message Queue)，主题被划分为一个或多个子主题，即消息队列。一个topic下可以设置多个消息队列，发送消息时执行该消息的topic，RocketMQ会轮询该topic下的所有队列将消息发出去。下图是Broker内部消息情况：
![请添加图片描述](https://img-blog.csdnimg.cn/d502d344f3404e53b07bfb95cc844a96.png)
其实Topic只是一个逻辑上的概念，下面的消息队列才是真正的实体。
### 消息消费模式
消息消费模式有两种：集群消费(Clustering)和广播消费(Broadcasting)
默认情况下就是集群消费，该模式一条消息只能被某一消费组中的某一台机器消费，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。
而广播消费消息会发送给消费者组中的每一个消费者进行消费。
### 消息顺序
消息顺序有两种：顺序消费和并行消费。
顺序消费表示消息消费的顺序和生产者为每个消息队列发送信息时候的顺序一致，所以如果正在处理全局顺序是强制性的场景，需要确保使用的主题只有一个消息队列。
并行消费不再保证消息顺序，消费的最大并行数量受每个消费者客户端指定的线程池限制。
# 3 设计理念
RocketMQ设计是基于主题的发布与订阅模式，其核心功能包括消息发送、消息存储、消息消费、整体设计追求简单与性能第一，主要体现在以下三个方面：
## 3.1 NameServer设计及其简单
RocketMQ摒弃了业界常用的Zookeeper作为注册中心，而是使用自研的NameServer来实现元数据的管理，因为topic的路由信息无须在集群间保持强一致性，追求最终一致性，并且能容忍分钟级的不一致，所以RocketMQ的NameServer集群间互不通信，极大降低了设计的复杂度，降低了对网络的要求，提升性能。
## 3.2 高效的IO存储机制
RocketMQ追求消息发送的高吞吐量，RocketMQ消息存储文件设计成文件组的概念，组内单个文件大小固定，方便引入内存映射机制，所有主题的消息存储基于顺序写，提升写性能，同时为了兼顾消息消费与消息查找，引入消息消费队列文件与索引文件。
## 3.3 容忍存在的设计缺陷
适当将某些工作下放给RocketMQ使用者。消息中间件的实现者经常会遇到一个难题：
如何保证消息一定能被消息消费者消费，并且保证只消费一次。 RocketMQ的设计者给出的解决办法是不解决这个难题，而是退而求其次，只保证消息被消费者消费，但设计上允许消息被重复消费，如果你们要用RocketMQ那么你们自己在消费端用逻辑实现只消费一次的功能。
# 4 RocketMQ架构
![请添加图片描述](https://img-blog.csdnimg.cn/0455813dfd0f4029bcf36a858a2f934c.png)
## 4.1 NameServer 集群
提供轻量级的服务发现及路由，每个NameServer记录完整的路由信息，提供相应的读写服务，支持快速存储扩展。
NameServer是一个功能齐全的服务器，主要包含两个功能：

 1. Broker管理，接收来自Broker集群的注册请求，提供心跳机制检测Broker是否存活
 2. 路由管理，每个NameServer持有全部有关Broker集群和客户端请求队列的路由信息
## 4.2 Broker 集群
通过提供轻量级的Topic和Queue机制处理消息存储。同时支持Push和Pull两种模型，包含容错机制。提供强大的峰值填充和以原始时间顺序累计数千亿条消息的能力。此外还提供灾难恢复，丰富的指标统计数据和警报机制，这些都是传统的消息系统缺乏的。

Broker有几个重要的子模块：

 1. 远程处理模块，Broker入口，处理来自客户端的请求
 2. 客户端管理，管理客户端(包括消息生产者和消费者)，维护消费者的主题订阅
 3. 存储服务，提供在物理硬盘上存储和查询消息的简单API
 4. HA服务，提供主从Broker间数据同步
 5. 索引服务，通过指定键为消息建立索引并提供快速消息查询
## 4.3 Producer 集群
消息生产者支持分布式部署，分布式生产者通过多种负载均衡模式向Broker集群发送消息。
## 4.4 Consumer 集群
消息消费者也支持Push和Pull模型的分布式部署，还支持集群消费和消息广播。提供实时的消息订阅机制，可以满足大多数消费者的需求。
## 架构图中集群间交互方式说明
 1. Broker Master 和Broker Slave是主从架构，会执行数据同步 Data Sync
 2. 每个Broker与NameServer集群中所有节点建立长连接，定时注册Topic信息到所有NameServer
 3. Producer与NameServer集群中的其中一个节点随机建立长连接，定期从NameServer获取Topic路由信息，并与提供Topic服务的Broker Master建立长连接，定时向Broker发送心跳
 4. Producer 只能将消息发送到 Broker Master，但是 Consumer 同时和 Broker Master 和 Broker Slave 建立长连接，既可以从 Master订阅消息，也可以从 Slave 订阅消息。
# 5 设计目标
## 5.1 架构模式
RocketMQ 与大部分消息中间件一样，采用发布订阅模式，基本的参与组件主要包括：消息发送者、消息服务器(消息存储)、消息消费、路由发现。
### 5.1.1 顺序消息
顺序消息(FIFO)是一种严格按照顺序进行发布和消费的消息类型，要求消息的发布和消息消费都按照顺序进行，RocketMQ 可以严格保证消息有序。

RocketMQ 可以严格保证消息有序，但这个顺序不是全局顺序，只是分区(queue)顺序。要全局顺序只能一个分区，但是同一条queue中，RocketMQ 的确是能保证FIFO的。
### 5.1.2 消息过滤
消息过滤是指在消息消费时，消息消费者可以对同一主题下的消息按照规则只消费自己感兴趣的消息。RocketMQ 消息过滤支持在服务端与消费端的消息过滤机制。

 1. 消息在 Broker 端过滤，Broker 只将消息消费者感兴趣的消息发送给消息消费者
 2. 消息在消息消费端过滤，消息过滤方式完全由消息消费者自定义，但缺点是有很多无用的消息会从 Broker 传输到消费端
### 5.1.3 消息存储
消息中间件的一个核心实现是消息的存储，对消息存储一般有如下两个维度的考量：消息堆积能力和消息存储性能

RocketMQ 追求消息存储的高性能，引入内存映射机制，所有主题的消息顺序存储在同一个文件中。同时为了避免消息无限在消息存储服务器中累积，引入了消息文件过期机制与文件存储空间报警机制。
## 5.2 消息高可用性
通常影响消息可靠性的有以下几种情况：

 1. Broker 正常关机
 2. Broker 异常宕机
 3. 操作系统宕机
 4. 机器断电，但是能立即恢复供电情况
 5. 机器无法开机(可能是CPU、主板、内存等关键设备损坏)
 6. 磁盘设备损坏

针对上述情况，情况1、4的RocketMQ在同步刷盘机制下可以确保不丢失消息，在异步刷盘模式下会丢失少量消息。情况5、6属于单点故障，一旦发生该节点上的消息全部丢失，如果开启异步复制机制RocketMQ能保证只丢失少量消息，RocketMQ在后续版本中将引入双写机制，以满足消息可靠性要求极高的场合。
### 5.2.1 消息到消费低延迟
RocketMQ 在消息不发生消息堆积时，以长轮询模式实现准实时的消息推送模式。
### 5.2.2 确保消息必须被消费一次(不是只消费一次)
RocketMQ 通过消息消费确认机制(ACK)来确保消息至少被消费一次，但由于ACK消息有可能丢失等其他原因，RocketMQ 无法做到消息只被消费一次，有重复消费的可能。
### 5.2.3 回溯消息
回溯消息是指消费端已经消费成功的消息，由于业务要求需要重新消费消息。RocketMQ 支持按时回溯消息，时间维度可精确到毫秒、可以向前或向后回溯。
### 5.2.4 消息堆积
消息中间件的主要功能是异步解耦，必须具备应对前端的数据洪峰，提供后端系统的可用性，必然要求消息中间件具备一定的消息堆积能力。RocketMQ 消息存储使用磁盘文件(内存映射机制)，并且在物理布局上为多个大小相等的文件组成逻辑文件组，可以无限循环使用。RocketMQ 消息存储文件并不是永久存储在消息服务器端，而是提供过期机制，默认保留3天。
### 5.2.5 定时消息
定时消息是指消息发送到 Broker 后，不能被消息消费端立即消费，要到特定的时间点或等待特定时间后才能被消费。如果要支持任意精度的定时消息消费，必须在消息服务端对消息进行排序，势必带来很大性能消耗，因此RocketMQ不支持任意进度的定时消息，而只支持特定延迟级别。
### 5.2.6 消息重试机制
消息重试是指消息在消费时，如果发送异常消息中间件需要支持消息重新投递，RocketMQ 支持消息重试机制。

